// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Array.jack

/**
 * Represents a dynamic array with automatic growth.
 * In the Jack language, arrays are instances of the Array class.
 * Once declared, the array entries can be accessed using the usual
 * syntax arr[i]. Each array entry can hold a primitive data type as
 * well as any object type. Different array entries can have different
 * data types.
 */
class Array {
    field int data;      // Pointer to the actual data
    field int capacity;  // Current capacity of the array
    field int size;      // Current number of elements

    /** Constructs a new Array of the given initial capacity. */
    constructor Array new(int initialCapacity) {
        if (initialCapacity <= 0) {
            let initialCapacity = 1;
        }
        let data = Memory.alloc(initialCapacity);
        let capacity = initialCapacity;
        let size = 0;
        return this;
    }


    /** Disposes this array. */
    method void dispose() {
        do Memory.free(data);
        return;
    }

    /** Returns the current capacity of the array. */
    method int capacity() {
        return capacity;
    }

    /** Returns the current size (number of elements) of the array. */
    method int size() {
        return size;
    }

    /** Gets the element at the given index. */
    method int get(int index) {
        if ((index < 0) | (index >= size)) {
            // Error: index out of bounds
            return 0;
        }
        return data[index];
    }

    /** Sets the element at the given index. */
    method void set(int index, int value) {
        if ((index < 0) | (index >= capacity)) {
            return; // Error: index out of bounds
        }
        let data[index] = value;
        if (index >= size) {
            let size = index + 1;
        }
        return;
    }

    /** Adds an element to the end of the array, growing if necessary. */
    method void append(int value) {
        if (size >= capacity) {
            do grow();
        }
        let data[size] = value;
        let size = size + 1;
        return;
    }

    /** Grows the array by doubling its capacity. */
    method void grow() {
        var int newData, newCapacity, i;
        let newCapacity = capacity * 2;
        let newData = Memory.alloc(newCapacity);

        if (newData = null) {
            return; // Failed to allocate memory
        }

        // Copy existing data
        do Array.copy(data, newData, size);

        // Free old memory and update fields
        do Memory.free(data);
        let data = newData;
        let capacity = newCapacity;
        return;
    }

    /** Shrinks the array to fit the current size. */
    method void shrinkToFit() {
        var int newData;
        if (size < capacity) {
            let newData = Memory.alloc(size);
            if (newData = null) {
                return; // Failed to allocate memory
            }
            do Array.copy(data, newData, size);
            do Memory.free(data);
            let data = newData;
            let capacity = size;
        }
        return;
    }

    /** Resizes the array to the given capacity. */
    method void resize(int newCapacity) {
        var int newData;
        if (newCapacity <= 0) {
            return;
        }

        let newData = Memory.alloc(newCapacity);
        if (newData = null) {
            return; // Failed to allocate memory
        }

        // Copy existing data (up to the smaller of old size or new capacity)
        if (size <= newCapacity) {
            do Array.copy(data, newData, size);
        } else {
            do Array.copy(data, newData, newCapacity);
            let size = newCapacity;
        }

        do Memory.free(data);
        let data = newData;
        let capacity = newCapacity;
        return;
    }

    /** Copies n elements from src array to dest array. */
    function void copy(int src, int dest, int n) {
        var int i;
        let i = 0;
        while (i < n) {
            let dest[i] = src[i];
            let i = i + 1;
        }
        return;
    }

    /** Copies n elements from src array to dest array starting at given offsets. */
    function void copyRange(int src, int srcOffset, int dest, int destOffset, int n) {
        var int i;
        let i = 0;
        while (i < n) {
            let dest[destOffset + i] = src[srcOffset + i];
            let i = i + 1;
        }
        return;
    }

    /** Fills the array with the given value. */
    method void fill(int value) {
        var int i;
        let i = 0;
        while (i < capacity) {
            let data[i] = value;
            let i = i + 1;
        }
        let size = capacity;
        return;
    }

    /** Clears the array (sets size to 0). */
    method void clear() {
        let size = 0;
        return;
    }

    /** Returns true if the array is empty. */
    method boolean isEmpty() {
        return size = 0;
    }

    /** Direct array access operator support (for arr[i] syntax). */
    method int __getitem__(int index) {
        return data[index];
    }

    /** Direct array access operator support (for arr[i] = value syntax). */
    method void __setitem__(int index, int value) {
        let data[index] = value;
        return;
    }
}
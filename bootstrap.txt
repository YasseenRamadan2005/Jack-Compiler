//Set 256 to be the start of the stack
@256
D=A 
@SP 
M=D 
//Set up the comparison ops subroutines
@SKIP 
0;JMP 
// ------------------------------------------------------------
//  Shared code for gt, lt, eq
//  Expectations on entry:
//Stack  – return address
//D  – (left – right)
// ------------------------------------------------------------
// want  (left  > right)  ⇔ (D > 0)
(DO_GT)
@RETURN_TRUE 
D;JGT 
@RETURN_FALSE 
0;JMP 
// want  (left == right)  ⇔ (D == 0)
(DO_EQ)
@RETURN_TRUE 
D;JEQ 
@RETURN_FALSE 
0;JMP 
// want  (left  < right)  ⇔ (D < 0)
(DO_LT)
@RETURN_TRUE 
D;JLT 
@RETURN_FALSE 
0;JMP 
// ---- set boolean in D --------------------------------------
(RETURN_TRUE)
D=-1 
@WRITE_BACK 
0;JMP 
(RETURN_FALSE)
D=0 
@WRITE_BACK 
0;JMP 
// ---- collapse stack and return -----------------------------
(WRITE_BACK)
@SP 
AM=M-1 
A=M 
0;JMP 
(SKIP)
//Set up calling and returning from functions
@SKIP1
0;JMP 
(CALL)
@SP 
AM=M+1 
A=A-1 
M=D 
@LCL 
D=M 
@SP 
AM=M+1 
A=A-1 
M=D 
@ARG 
D=M 
@SP 
AM=M+1 
A=A-1 
M=D 
@THIS 
D=M 
@SP 
AM=M+1 
A=A-1 
M=D 
@THAT 
D=M 
@SP 
AM=M+1 
A=A-1 
M=D 
@14 
D=M 
@SP 
D=M-D 
@ARG 
M=D 
@SP 
D=M 
@LCL 
M=D 
@13 
A=M 
0;JMP 
(RETURN)
@LCL 
D=M 
@14 
M=D 
@5 
A=D-A 
D=M 
@15 
M=D 
@SP 
AM=M-1 
D=M 
@ARG 
A=M 
M=D 
@ARG 
D=M 
@SP 
M=D+1 
@14 
A=M-1 
D=M 
@THAT 
M=D 
@14 
A=M-1 
A=A-1 
D=M 
@THIS 
M=D 
@14 
A=M-1 
A=A-1 
A=A-1 
D=M 
@ARG 
M=D 
@14 
A=M-1 
A=A-1 
A=A-1 
A=A-1 
D=M 
@LCL 
M=D 
@15 
A=M 
0;JMP
(PUSH_D)
@SP
AM=M+1
A=M-1
M=D
@13
A=M
(ARGUMENT)
@ARG
A=D+M
D=M
@PUSH_D
0;JMP
(ARGUMENT)
@ARG
A=D+M
D=M
@PUSH_D
0;JMP
(ARGUMENT)
@ARG
A=D+M
D=M
@PUSH_D
0;JMP
(LOCAL)
@LCL
A=D+M
D=M
@PUSH_D
0;JMP
(THIS)
@THIS
A=D+M
D=M
@PUSH_D
0;JMP
(THAT)
@THAT
A=D+M
D=M
@PUSH_D
0;JMP
(SKIP1)
<CLASS>
  <KEYWORD> class </KEYWORD>
  <IDENTIFIER> Memory </IDENTIFIER>
  <SYMBOL> { </SYMBOL>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> HEAP_START </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 2048 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> HEAP_INIT_SIZE </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 14428 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> node_size </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> node_hole </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> node_prev </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 2 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> node_next </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 3 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <CONSTANT_DEC>
    <KEYWORD> constant </KEYWORD>
    <TERM>
      <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
    </TERM>
    <TERM>
      <INTEGER_CONSTANT> 7 </INTEGER_CONSTANT>
    </TERM>
    <SYMBOL> ; </SYMBOL>
  </CONSTANT_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> init </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> i </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> block_size </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> i </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> i </IDENTIFIER>
            </TERM>
            <SYMBOL> &lt; </SYMBOL>
            <TERM>
              <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> HEAP_START </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> i </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <KEYWORD> null </KEYWORD>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> i </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> i </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> HEAP_START </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_size </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> HEAP_INIT_SIZE </IDENTIFIER>
            </TERM>
            <SYMBOL> - </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> HEAP_START </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_hole </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> HEAP_START </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_prev </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> HEAP_START </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_next </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> create_foot </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> HEAP_START </IDENTIFIER>
                <SYMBOL> [ </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ] </SYMBOL>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> add_node </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> HEAP_START </IDENTIFIER>
                <SYMBOL> [ </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> Memory </IDENTIFIER>
                    <SYMBOL> . </SYMBOL>
                    <IDENTIFIER> getBinIndex </IDENTIFIER>
                    <SYMBOL> ( </SYMBOL>
                    <EXPRESSION_LIST>
                      <EXPRESSION>
                        <TERM>
                          <IDENTIFIER> HEAP_INIT_SIZE </IDENTIFIER>
                        </TERM>
                        <SYMBOL> - </SYMBOL>
                        <TERM>
                          <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
                        </TERM>
                      </EXPRESSION>
                    </EXPRESSION_LIST>
                    <SYMBOL> ) </SYMBOL>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ] </SYMBOL>
              </TERM>
            </EXPRESSION>
            <SYMBOL> , </SYMBOL>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> HEAP_START </IDENTIFIER>
                <SYMBOL> [ </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ] </SYMBOL>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> alloc </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> size </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> index </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> temp </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> found </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> remaining_size </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> new_node </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> index </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> getBinIndex </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> size </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> temp </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> HEAP_START </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> index </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> found </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> get_best_fit </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> temp </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> , </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> size </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <SYMBOL> ~ </SYMBOL>
              <TERM>
                <IDENTIFIER> found </IDENTIFIER>
              </TERM>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <IF_STATEMENT>
              <KEYWORD> if </KEYWORD>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <SYMBOL> ( </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> index </IDENTIFIER>
                    </TERM>
                    <SYMBOL> + </SYMBOL>
                    <TERM>
                      <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ) </SYMBOL>
                </TERM>
                <SYMBOL> &gt;= </SYMBOL>
                <TERM>
                  <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> { </SYMBOL>
              <STATEMENTS>
                <RETURN_STATEMENT>
                  <KEYWORD> return </KEYWORD>
                  <EXPRESSION>
                    <TERM>
                      <KEYWORD> null </KEYWORD>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ; </SYMBOL>
                </RETURN_STATEMENT>
              </STATEMENTS>
              <SYMBOL> } </SYMBOL>
            </IF_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> index </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> index </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> temp </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> HEAP_START </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> index </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> found </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> Memory </IDENTIFIER>
                  <SYMBOL> . </SYMBOL>
                  <IDENTIFIER> get_best_fit </IDENTIFIER>
                  <SYMBOL> ( </SYMBOL>
                  <EXPRESSION_LIST>
                    <EXPRESSION>
                      <TERM>
                        <IDENTIFIER> temp </IDENTIFIER>
                      </TERM>
                    </EXPRESSION>
                    <SYMBOL> , </SYMBOL>
                    <EXPRESSION>
                      <TERM>
                        <IDENTIFIER> size </IDENTIFIER>
                      </TERM>
                    </EXPRESSION>
                  </EXPRESSION_LIST>
                  <SYMBOL> ) </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> remove_node </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> HEAP_START </IDENTIFIER>
                <SYMBOL> [ </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> Memory </IDENTIFIER>
                    <SYMBOL> . </SYMBOL>
                    <IDENTIFIER> getBinIndex </IDENTIFIER>
                    <SYMBOL> ( </SYMBOL>
                    <EXPRESSION_LIST>
                      <EXPRESSION>
                        <TERM>
                          <IDENTIFIER> found </IDENTIFIER>
                          <SYMBOL> [ </SYMBOL>
                          <EXPRESSION>
                            <TERM>
                              <IDENTIFIER> node_size </IDENTIFIER>
                            </TERM>
                          </EXPRESSION>
                          <SYMBOL> ] </SYMBOL>
                        </TERM>
                      </EXPRESSION>
                    </EXPRESSION_LIST>
                    <SYMBOL> ) </SYMBOL>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ] </SYMBOL>
              </TERM>
            </EXPRESSION>
            <SYMBOL> , </SYMBOL>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> found </IDENTIFIER>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> remaining_size </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> found </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
            <SYMBOL> - </SYMBOL>
            <TERM>
              <IDENTIFIER> size </IDENTIFIER>
            </TERM>
            <SYMBOL> - </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> remaining_size </IDENTIFIER>
            </TERM>
            <SYMBOL> &gt;= </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> found </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> found </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_hole </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> create_foot </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> found </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> new_node </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> found </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <IDENTIFIER> size </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 4 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> new_node </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> remaining_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> new_node </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_hole </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> create_foot </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> new_node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> add_node </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> HEAP_START </IDENTIFIER>
                    <SYMBOL> [ </SYMBOL>
                    <EXPRESSION>
                      <TERM>
                        <IDENTIFIER> Memory </IDENTIFIER>
                        <SYMBOL> . </SYMBOL>
                        <IDENTIFIER> getBinIndex </IDENTIFIER>
                        <SYMBOL> ( </SYMBOL>
                        <EXPRESSION_LIST>
                          <EXPRESSION>
                            <TERM>
                              <IDENTIFIER> remaining_size </IDENTIFIER>
                            </TERM>
                          </EXPRESSION>
                        </EXPRESSION_LIST>
                        <SYMBOL> ) </SYMBOL>
                      </TERM>
                    </EXPRESSION>
                    <SYMBOL> ] </SYMBOL>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> , </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> new_node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
          <KEYWORD> else </KEYWORD>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> found </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_hole </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> create_foot </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> found </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> found </IDENTIFIER>
            </TERM>
            <SYMBOL> + </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> calloc </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> size </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> foo </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> foo </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> alloc </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> size </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <SYMBOL> ~ </SYMBOL>
              <TERM>
                <IDENTIFIER> foo </IDENTIFIER>
              </TERM>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <RETURN_STATEMENT>
              <KEYWORD> return </KEYWORD>
              <EXPRESSION>
                <TERM>
                  <KEYWORD> null </KEYWORD>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </RETURN_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> size </IDENTIFIER>
            </TERM>
            <SYMBOL> &gt; </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> size </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> size </IDENTIFIER>
                </TERM>
                <SYMBOL> - </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> foo </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> foo </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> free </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> ptr </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> node </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> prev_node </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> next_node </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> node </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> ptr </IDENTIFIER>
            </TERM>
            <SYMBOL> - </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> node </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_hole </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> prev_node </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> getPrevNode </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> next_node </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> getNextNode </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> prev_node </IDENTIFIER>
            </TERM>
            <SYMBOL> &amp; </SYMBOL>
            <TERM>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> prev_node </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_hole </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> = </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> remove_node </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> HEAP_START </IDENTIFIER>
                    <SYMBOL> [ </SYMBOL>
                    <EXPRESSION>
                      <TERM>
                        <IDENTIFIER> Memory </IDENTIFIER>
                        <SYMBOL> . </SYMBOL>
                        <IDENTIFIER> getBinIndex </IDENTIFIER>
                        <SYMBOL> ( </SYMBOL>
                        <EXPRESSION_LIST>
                          <EXPRESSION>
                            <TERM>
                              <IDENTIFIER> prev_node </IDENTIFIER>
                              <SYMBOL> [ </SYMBOL>
                              <EXPRESSION>
                                <TERM>
                                  <IDENTIFIER> node_size </IDENTIFIER>
                                </TERM>
                              </EXPRESSION>
                              <SYMBOL> ] </SYMBOL>
                            </TERM>
                          </EXPRESSION>
                        </EXPRESSION_LIST>
                        <SYMBOL> ) </SYMBOL>
                      </TERM>
                    </EXPRESSION>
                    <SYMBOL> ] </SYMBOL>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> , </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> prev_node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> prev_node </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> prev_node </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <IDENTIFIER> node </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> create_foot </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> prev_node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> prev_node </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> next_node </IDENTIFIER>
            </TERM>
            <SYMBOL> &amp; </SYMBOL>
            <TERM>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> next_node </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_hole </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> = </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> remove_node </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> HEAP_START </IDENTIFIER>
                    <SYMBOL> [ </SYMBOL>
                    <EXPRESSION>
                      <TERM>
                        <IDENTIFIER> Memory </IDENTIFIER>
                        <SYMBOL> . </SYMBOL>
                        <IDENTIFIER> getBinIndex </IDENTIFIER>
                        <SYMBOL> ( </SYMBOL>
                        <EXPRESSION_LIST>
                          <EXPRESSION>
                            <TERM>
                              <IDENTIFIER> next_node </IDENTIFIER>
                              <SYMBOL> [ </SYMBOL>
                              <EXPRESSION>
                                <TERM>
                                  <IDENTIFIER> node_size </IDENTIFIER>
                                </TERM>
                              </EXPRESSION>
                              <SYMBOL> ] </SYMBOL>
                            </TERM>
                          </EXPRESSION>
                        </EXPRESSION_LIST>
                        <SYMBOL> ) </SYMBOL>
                      </TERM>
                    </EXPRESSION>
                    <SYMBOL> ] </SYMBOL>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> , </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> next_node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <IDENTIFIER> next_node </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <DO_STATEMENT>
              <KEYWORD> do </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> create_foot </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> node </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> ; </SYMBOL>
            </DO_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> add_node </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> HEAP_START </IDENTIFIER>
                <SYMBOL> [ </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> getBinIndex </IDENTIFIER>
                    <SYMBOL> ( </SYMBOL>
                    <EXPRESSION_LIST>
                      <EXPRESSION>
                        <TERM>
                          <IDENTIFIER> node </IDENTIFIER>
                          <SYMBOL> [ </SYMBOL>
                          <EXPRESSION>
                            <TERM>
                              <IDENTIFIER> node_size </IDENTIFIER>
                            </TERM>
                          </EXPRESSION>
                          <SYMBOL> ] </SYMBOL>
                        </TERM>
                      </EXPRESSION>
                    </EXPRESSION_LIST>
                    <SYMBOL> ) </SYMBOL>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ] </SYMBOL>
              </TERM>
            </EXPRESSION>
            <SYMBOL> , </SYMBOL>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> node </IDENTIFIER>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> realloc </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> ptr </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> newSize </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> oldSize </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> newPtr </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> copySize </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> foo </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> ptr </IDENTIFIER>
            </TERM>
            <SYMBOL> = </SYMBOL>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <RETURN_STATEMENT>
              <KEYWORD> return </KEYWORD>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> Memory </IDENTIFIER>
                  <SYMBOL> . </SYMBOL>
                  <IDENTIFIER> alloc </IDENTIFIER>
                  <SYMBOL> ( </SYMBOL>
                  <EXPRESSION_LIST>
                    <EXPRESSION>
                      <TERM>
                        <IDENTIFIER> newSize </IDENTIFIER>
                      </TERM>
                    </EXPRESSION>
                  </EXPRESSION_LIST>
                  <SYMBOL> ) </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </RETURN_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> foo </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> ptr </IDENTIFIER>
            </TERM>
            <SYMBOL> - </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> oldSize </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> foo </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> newPtr </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> . </SYMBOL>
              <IDENTIFIER> alloc </IDENTIFIER>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION_LIST>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> newSize </IDENTIFIER>
                  </TERM>
                </EXPRESSION>
              </EXPRESSION_LIST>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> newPtr </IDENTIFIER>
            </TERM>
            <SYMBOL> = </SYMBOL>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <RETURN_STATEMENT>
              <KEYWORD> return </KEYWORD>
              <EXPRESSION>
                <TERM>
                  <KEYWORD> null </KEYWORD>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </RETURN_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> oldSize </IDENTIFIER>
            </TERM>
            <SYMBOL> &lt;= </SYMBOL>
            <TERM>
              <IDENTIFIER> newSize </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> copySize </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> oldSize </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
          <KEYWORD> else </KEYWORD>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> copySize </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> newSize </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> copy </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> ptr </IDENTIFIER>
              </TERM>
            </EXPRESSION>
            <SYMBOL> , </SYMBOL>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> newPtr </IDENTIFIER>
              </TERM>
            </EXPRESSION>
            <SYMBOL> , </SYMBOL>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> copySize </IDENTIFIER>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> free </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> ptr </IDENTIFIER>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> newPtr </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> copy </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> src </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> dst </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> length </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> i </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> i </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> i </IDENTIFIER>
            </TERM>
            <SYMBOL> &lt; </SYMBOL>
            <TERM>
              <IDENTIFIER> length </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> Memory </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> dst </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <IDENTIFIER> i </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> Memory </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> src </IDENTIFIER>
                    </TERM>
                    <SYMBOL> + </SYMBOL>
                    <TERM>
                      <IDENTIFIER> i </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> i </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> i </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> remove_node </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> bin_p </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> node_p </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <STATEMENTS>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_next </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
          <KEYWORD> else </KEYWORD>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> bin_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_next </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_prev </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> node_p </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_prev </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> node_p </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_next </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> getBinIndex </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> size </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> i </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> i </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> i </IDENTIFIER>
            </TERM>
            <SYMBOL> &lt; </SYMBOL>
            <TERM>
              <IDENTIFIER> AMOUNT_OF_BINS </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <IF_STATEMENT>
              <KEYWORD> if </KEYWORD>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> size </IDENTIFIER>
                </TERM>
                <SYMBOL> &lt;= </SYMBOL>
                <TERM>
                  <SYMBOL> ( </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <SYMBOL> ( </SYMBOL>
                      <EXPRESSION>
                        <TERM>
                          <IDENTIFIER> i </IDENTIFIER>
                        </TERM>
                        <SYMBOL> + </SYMBOL>
                        <TERM>
                          <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                        </TERM>
                      </EXPRESSION>
                      <SYMBOL> ) </SYMBOL>
                    </TERM>
                    <SYMBOL> * </SYMBOL>
                    <TERM>
                      <INTEGER_CONSTANT> 16 </INTEGER_CONSTANT>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ) </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> { </SYMBOL>
              <STATEMENTS>
                <RETURN_STATEMENT>
                  <KEYWORD> return </KEYWORD>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> i </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ; </SYMBOL>
                </RETURN_STATEMENT>
              </STATEMENTS>
              <SYMBOL> } </SYMBOL>
            </IF_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> i </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> i </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 1 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 7 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> get_best_fit </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> bin_p </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> size </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> temp </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> temp </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> bin_p </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> temp </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <IF_STATEMENT>
              <KEYWORD> if </KEYWORD>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> temp </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> &gt;= </SYMBOL>
                <TERM>
                  <IDENTIFIER> size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> { </SYMBOL>
              <STATEMENTS>
                <RETURN_STATEMENT>
                  <KEYWORD> return </KEYWORD>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> temp </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ; </SYMBOL>
                </RETURN_STATEMENT>
              </STATEMENTS>
              <SYMBOL> } </SYMBOL>
            </IF_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> temp </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> temp </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_next </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> get_foot </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> node_p </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <STATEMENTS>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_p </IDENTIFIER>
            </TERM>
            <SYMBOL> + </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 4 </INTEGER_CONSTANT>
            </TERM>
            <SYMBOL> + </SYMBOL>
            <TERM>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> create_foot </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> head </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <STATEMENTS>
        <DO_STATEMENT>
          <KEYWORD> do </KEYWORD>
          <IDENTIFIER> Memory </IDENTIFIER>
          <SYMBOL> . </SYMBOL>
          <IDENTIFIER> poke </IDENTIFIER>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION_LIST>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> get_foot </IDENTIFIER>
                <SYMBOL> ( </SYMBOL>
                <EXPRESSION_LIST>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> head </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                </EXPRESSION_LIST>
                <SYMBOL> ) </SYMBOL>
              </TERM>
            </EXPRESSION>
            <SYMBOL> , </SYMBOL>
            <EXPRESSION>
              <TERM>
                <IDENTIFIER> head </IDENTIFIER>
              </TERM>
            </EXPRESSION>
          </EXPRESSION_LIST>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> ; </SYMBOL>
        </DO_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> add_node </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> bin_p </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> node_p </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> current </IDENTIFIER>
        <SYMBOL> , </SYMBOL>
        <IDENTIFIER> prev </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> node_p </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_prev </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> node_p </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node_next </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <SYMBOL> ~ </SYMBOL>
              <TERM>
                <IDENTIFIER> bin_p </IDENTIFIER>
                <SYMBOL> [ </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ] </SYMBOL>
              </TERM>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> bin_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <RETURN_STATEMENT>
              <KEYWORD> return </KEYWORD>
              <SYMBOL> ; </SYMBOL>
            </RETURN_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> current </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> bin_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> prev </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <WHILE_STATEMENT>
          <KEYWORD> while </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <SYMBOL> ~ </SYMBOL>
              <TERM>
                <SYMBOL> ( </SYMBOL>
                <EXPRESSION>
                  <TERM>
                    <IDENTIFIER> current </IDENTIFIER>
                  </TERM>
                  <SYMBOL> = </SYMBOL>
                  <TERM>
                    <KEYWORD> null </KEYWORD>
                  </TERM>
                </EXPRESSION>
                <SYMBOL> ) </SYMBOL>
              </TERM>
            </TERM>
            <SYMBOL> &amp; </SYMBOL>
            <TERM>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> current </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> &lt;= </SYMBOL>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> prev </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> current </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> current </IDENTIFIER>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> current </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_next </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </WHILE_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <SYMBOL> ~ </SYMBOL>
              <TERM>
                <IDENTIFIER> prev </IDENTIFIER>
              </TERM>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> bin_p </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> bin_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> bin_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
          <KEYWORD> else </KEYWORD>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> current </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> node_p </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
            <IF_STATEMENT>
              <KEYWORD> if </KEYWORD>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> current </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
              <SYMBOL> { </SYMBOL>
              <STATEMENTS>
                <LET_STATEMENT>
                  <KEYWORD> let </KEYWORD>
                  <IDENTIFIER> current </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_prev </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                  <SYMBOL> = </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_p </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ; </SYMBOL>
                </LET_STATEMENT>
              </STATEMENTS>
              <SYMBOL> } </SYMBOL>
            </IF_STATEMENT>
            <LET_STATEMENT>
              <KEYWORD> let </KEYWORD>
              <IDENTIFIER> prev </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
              <SYMBOL> = </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_p </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </LET_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> getPrevNode </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> node </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> prev </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> prev </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node </IDENTIFIER>
            </TERM>
            <SYMBOL> - </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <SYMBOL> ( </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> prev </IDENTIFIER>
                  <SYMBOL> [ </SYMBOL>
                  <EXPRESSION>
                    <TERM>
                      <IDENTIFIER> node_size </IDENTIFIER>
                    </TERM>
                  </EXPRESSION>
                  <SYMBOL> ] </SYMBOL>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <IDENTIFIER> prev </IDENTIFIER>
                </TERM>
                <SYMBOL> + </SYMBOL>
                <TERM>
                  <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ) </SYMBOL>
            </TERM>
            <SYMBOL> = </SYMBOL>
            <TERM>
              <IDENTIFIER> node </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <RETURN_STATEMENT>
              <KEYWORD> return </KEYWORD>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> prev </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </RETURN_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> getNextNode </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> node </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <VAR_DEC>
        <KEYWORD> var </KEYWORD>
        <KEYWORD> int </KEYWORD>
        <IDENTIFIER> next </IDENTIFIER>
        <SYMBOL> ; </SYMBOL>
      </VAR_DEC>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> next </IDENTIFIER>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> node </IDENTIFIER>
            </TERM>
            <SYMBOL> + </SYMBOL>
            <TERM>
              <IDENTIFIER> node </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
            <SYMBOL> + </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 5 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <IF_STATEMENT>
          <KEYWORD> if </KEYWORD>
          <SYMBOL> ( </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> next </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> node_size </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
            <SYMBOL> &gt; </SYMBOL>
            <TERM>
              <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ) </SYMBOL>
          <SYMBOL> { </SYMBOL>
          <STATEMENTS>
            <RETURN_STATEMENT>
              <KEYWORD> return </KEYWORD>
              <EXPRESSION>
                <TERM>
                  <IDENTIFIER> next </IDENTIFIER>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ; </SYMBOL>
            </RETURN_STATEMENT>
          </STATEMENTS>
          <SYMBOL> } </SYMBOL>
        </IF_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <KEYWORD> null </KEYWORD>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> void </KEYWORD>
    <IDENTIFIER> poke </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> x </IDENTIFIER>
      <SYMBOL> , </SYMBOL>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> y </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <STATEMENTS>
        <LET_STATEMENT>
          <KEYWORD> let </KEYWORD>
          <IDENTIFIER> x </IDENTIFIER>
          <SYMBOL> [ </SYMBOL>
          <EXPRESSION>
            <TERM>
              <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ] </SYMBOL>
          <SYMBOL> = </SYMBOL>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> y </IDENTIFIER>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </LET_STATEMENT>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SUBROUTINE_DEC>
    <KEYWORD> function </KEYWORD>
    <KEYWORD> int </KEYWORD>
    <IDENTIFIER> peek </IDENTIFIER>
    <SYMBOL> ( </SYMBOL>
    <PARAMETER_LIST>
      <KEYWORD> int </KEYWORD>
      <IDENTIFIER> x </IDENTIFIER>
    </PARAMETER_LIST>
    <SYMBOL> ) </SYMBOL>
    <SUBROUTINE_BODY>
      <SYMBOL> { </SYMBOL>
      <STATEMENTS>
        <RETURN_STATEMENT>
          <KEYWORD> return </KEYWORD>
          <EXPRESSION>
            <TERM>
              <IDENTIFIER> x </IDENTIFIER>
              <SYMBOL> [ </SYMBOL>
              <EXPRESSION>
                <TERM>
                  <INTEGER_CONSTANT> 0 </INTEGER_CONSTANT>
                </TERM>
              </EXPRESSION>
              <SYMBOL> ] </SYMBOL>
            </TERM>
          </EXPRESSION>
          <SYMBOL> ; </SYMBOL>
        </RETURN_STATEMENT>
      </STATEMENTS>
      <SYMBOL> } </SYMBOL>
    </SUBROUTINE_BODY>
  </SUBROUTINE_DEC>
  <SYMBOL> } </SYMBOL>
</CLASS>

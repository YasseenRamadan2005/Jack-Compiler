// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */
class Memory {
    static Array RAM_Array;

    /** Initializes the class. */
    function void init() {
        let RAM_Array = 0;
        let RAM_Array[2048] = 14335; // Heap size. Beginning of freeList at 2048
        let RAM_Array[2049] = null;  // Previous pointer
        let RAM_Array[2050] = null;  // Next pointer
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return RAM_Array[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let RAM_Array[address] = value;
        return;
    }

    /** Allocates a block of memory of the given size. */
    function Array alloc(int size) {
        var int i;
        var Array block;
        let i = 2048;

        // Traverse through the free list
        while (~(i = 0)) {
            if (i[0] > (size + 3)) {
                let i[0] = i[0] - size - 1;      // Reduce the size of the current segment
                let block = i + i[0];             // Block start address
                let block[-1] = size;             // Store block size in block[-1]
                
                if (i[0] < 5) {                  // If the remaining segment is too small
                    do Memory.mergeWithNeighbor(i);  // Merge with previous (i[1] is previous)
                }
                return block;  // Return the allocated block
            }
            let i = i[2];  // Move to the next segment in the free list
        }

        return 0;  // Failure to allocate
    }


    /** Deallocates a block of memory. */
    function void deAlloc(Array o) {
        var int segment, i;
        let segment = o - 1;         // Start of the segment
        let segment[0] = o[-1];      // Size of the segment
        let segment[1] = null;       // Reset previous pointer
        let segment[2] = null;       // Reset next pointer
        let i = 2048;

        // Traverse to the end of the free list
        while (~(i[2] = 0)) {
            let i = i[2];
        }

        // Insert the deallocated segment at the end of the free list
        let i[2] = segment;
        let segment[1] = i;

        // Merge with adjacent segments if possible
        do Memory.mergeWithNeighbor(segment);
        return;
    }


    /**
    * Reallocate memory to a new size.
    * If resizing is successful, the original block is adjusted. If a new block
    * is allocated, data is copied, and the original block is freed.
    */
    function Array realloc(Array block, int newSize) {
        var int currentSize;
        var Array newBlock, nextBlock;

        if (block = null) {
            return Memory.alloc(newSize);
        }
        
        if (newSize = 0) {
            do Memory.deAlloc(block);
            return null;
        }

        let currentSize = block[-1];
        //a >= b is the same as ~(b > a)
        if (currentSize < newSize) {
            // If the new size is larger, attempt to expand the block           
            // Get the next block in the free list
            let nextBlock = block[2];

            // Check if the next block is adjacent and has enough space
            if (~(nextBlock = null) & ((block + block[0] + 1) = nextBlock) & (~((newSize - block[0]) > nextBlock[0]))) {
                // Merge the current block with the next block to expand in place
                do Memory.mergeWithNeighbor(block);
                let block[-1] = newSize;
                return block;
            } else {
                // Allocate a new block
                let newBlock = Memory.alloc(newSize);
                if (newBlock = null) {
                    // Allocation failed
                    return null;
                }

                // Copy data from the old block to the new block
                do Memory.copy(block, newBlock, currentSize);

                // Free the old block
                do Memory.deAlloc(block);

                return newBlock;
            }
        } else {
            let block[-1] = newSize;
            return block;
        }
    }



    /** Merges a segment with its neighbors if they are adjacent. */
    function void mergeWithNeighbor(Array segment) {
        var int previous, next, nextNext;

        // Get the previous and next pointers
        let previous = segment[1];  // segment[1] -> previous
        let next = segment[2];      // segment[2] -> next

        // Merge with the next segment if they are adjacent
        if (~(next = 0)) {
            if (((segment + segment[0] + 1) = next) & (next[1] = segment)) { // Check adjacency
                let segment[0] = segment[0] + next[0] + 1; // Expand segment size
                let segment[2] = next[2];                   // Update next pointer

                // Update next-next's previous pointer, if it exists
                if (~(next[2] = 0)) {
                    let nextNext = Memory.peek(next[2] + 1);  // next[2] is the next segment
                    do Memory.poke(next[2] + 1, segment);  // Update next's previous pointer
                }
            }
        }

        // Merge with the previous segment if they are adjacent
        if (~(previous = 0)) {
            if(((previous + previous[0] + 1) = segment) & (previous[2] = segment)) { // Check adjacency
                let previous[0] = previous[0] + segment[0] + 1; // Expand previous size
                let previous[2] = segment[2];                    // Update next pointer

                // Update segment's next's previous pointer, if it exists
                if (~(segment[2] = 0)) {
                    let next = segment[2];
                    let next[1] = previous;
                }
            }
        }

        return;
    }

    //Sets RAM[address to address+size] to value
    function void set(int address, int value, int size){
        while(size > 0){
            let size = size - 1;
            let address[size] = value;
        }
        return;
    }

    function void clear(int address, int size){
        do Memory.set(address, 0 ,size);
        return;
    }


    function void copy(int source, int dest, int size) {
        while (size > 0) {
            let size = size - 1;
            let dest[size] = source[size];
        }
        return;
    }


}

